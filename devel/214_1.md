# [214_1] 

## 任务相关的代码文件
- 3rdparty/nlohmann_json/include/nlohmann/json.hpp
- goldfish/liii/njson.scm
- src/goldfish.hpp
- tests/goldfish/liii/njson-test.scm
- xmake.lua
- xmake/packages/n/nlohmann_json/xmake.lua
- devel/214_1.md


## 如何测试
```bash
xmake f -c --yes -vD
xmake b goldfish
bin/goldfish tests/goldfish/liii/njson-test.scm
bin/goldfish tests/test_all.scm
```

## 2026/2/24 引入 nlohmann_json 并初步完成 njson 

### What

1. 构建与依赖：在 `xmake.lua` 中新增 `nlohmann_json` 依赖（`v3.11.3`），新增本地包脚本 `xmake/packages/n/nlohmann_json/xmake.lua`，并通过 `set_sourcedir(...)` 指向 `3rdparty/nlohmann_json`，避免远程拉取。
2. C++ 运行时：在 `src/goldfish.hpp` 新增 `g_njson-*` 原语并注册到 `glue_for_community_edition`，覆盖 `string->json`、`json->string`、`handle?`、`free`、`ref/set/push/drop`、`contains-key?`、`keys`。
3. Scheme API：新增 `goldfish/liii/njson.scm`，导出统一 `njson-*` 接口，不再导出 `(liii json)` 同名别名，并在 Scheme 层补充参数校验。
4. 测试与基准：新增 `tests/goldfish/liii/njson-test.scm`，覆盖功能测试与 8 项性能对比，基准采用 `round-count=7` 的中位数统计，数据规模为 `bench-top-key-count=600`、`bench-array-length=600`。

### Why
1. 需要一个直接基于 `nlohmann::json` 的实现路径，减少 `liii json` 在大对象上的 Scheme 结构转换和线性扫描开销。
2. 需要可离线、可复现的依赖安装流程，避免构建阶段拉取远程仓库。
3. 需要对新接口进行功能正确性和性能收益的可量化验证。

### How
1. 使用句柄模型 `(njson-handle . id)`：底层以 `std::vector<std::unique_ptr<json>>` 存储实体，并通过 `njson_handle_free_ids` 复用已释放槽位。
2. 采用严格 JSON 语义：object key 仅接受 `string?`，symbol 值仅接受 `'null`。
3. 保持函数式更新语义：`njson-set/push/drop` 采用“复制后修改并返回新句柄”，不原地修改旧句柄。
4. 返回值策略：`njson-ref` 命中对象/数组时返回新句柄，命中标量时返回 Scheme 标量。

## 验证结果
本次对比文档编写前已执行：
1. ✅ `xmake b goldfish` 通过。
2. ✅ `bin/goldfish tests/goldfish/liii/njson-test.scm` 通过。
3. ✅ `bin/goldfish tests/test_all.scm` 通过（包含 `njson-test.scm` 在内的套件均 PASS）。

### njson-test 本次实测基准输出（节选）
- 解析(string->json): `liii/nlohmann = 12.85x`
- 序列化(json->string): `liii/nlohmann = 17.38x`
- 读取(json-ref): `liii/nlohmann = 520.37x`
- 修改(json-set): `liii/nlohmann = 2.62x`
- 插入(json-push): `liii/nlohmann = 5.19x`
- 删除(json-drop): `liii/nlohmann = 1.81x`
- 键存在(json-contains-key?): `liii/nlohmann = 341.95x`
- 获取键(json-keys): `liii/nlohmann = 2.30x`
